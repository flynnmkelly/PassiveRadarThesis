\chapter{Results and Discussion \label{sec:results}}

\section{Testbed Verification \label{sec:testbedResults}}
Before the testbed was used to facilitate comparison between different SDR modules detection performance, its design and components were tested according to the steps in the methodology section. Whilst this was relatively straightforward, it was necessary to ensure the project could meet its aims of a simple, user friendly, potentially scaleable design. 

\subsection{SDR Module Verification \label{sec:sdrVerification}}
The RTL-SDR and LimeSDR Mini were tested to ensure they could be used in the testbed. This comprised of testing both the software driver functionality as mentioned in Section \ref{sec:SDRmodules} and the hardware / communication functionality. 
% RTL SDR TESTING
\par \vspace{0.5cm}
\noindent
\textbf{RTL-SDR}
The RTL-SDR was tested using a combination of librtlsdr command line tools and GQRX, both on the mac and the Rpi5. Starting with the below command to ensure the hardware was detectable:

\begin{verbatim}
    rtl_test -t
\end{verbatim}

\noindent 
In conjunction with the antenna testing below \ref{sec:antennaVerification}, the RTL-SDR waterfall plot was obtained via GQRX, as seen in Figure \ref{fig:rtlSDRwaterfall}.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.6\textwidth]{smaAntennaNF.png}
    \caption{RTL-SDR Waterfall Plot (DAB Multiplex 9A)}
    \label{fig:rtlSDRwaterfall}
\end{figure}

Given that the relevant data processing was to be conducted with a python script, it was also neccessary to test the ability of the RTL-SDR to sample and output data to a .bin file. This was done using the following command:
\begin{verbatim}
    rtl_sdr -s 2048000 -f 202.928e6 -n 2048000 testData.bin 
\end{verbatim}

\noindent
The above test was successful in saving raw IQ data to a .bin file, in the executed directory. Where the saple rate was 2.048 MS/s, the centre frequency was 202.928 MHz (DAB Multiplex 9A) and the number of samples was 2048000 (1 second of data). The \textit{testData.bin} file size for the above example was 4.1MB, highlighting the importance of the storage medium as the sample time is scaled up, as discussed in Section \ref{sec:sbcVerification}.   

\par \vspace{0.5cm}
\noindent
\textbf{LimeSDR}
As with the RTL-SDR, the LimeSDR hardware and software was verified, however it required more effort to test given the relative lack of driver API's. Firstly, the hardware was tested using the Limesuite Hardware API:
\begin{verbatim}
    LimeUtil --find
    LimeQuickTest
\end{verbatim}

\noindent
Which worked to first detect the LimeSDR and then run a series of tests to ensure the hardware was functioning correctly. Specifically the quick test verfied functionality of the clock network, FPGA EEPROM, LMS7002M tuner chip, and the RF loopback. Once the physical hardware was verified it was necessary to ensure that the SoapySDR unifying API was working correctly and could detect the LimeSDR. This was done using the SoapySDRUtil command line tool and output:

\begin{verbatim}
    SoapySDRUtil --find
    ######################################################
    ##     Soapy SDR -- the SDR abstraction library     ##
    ######################################################
    Found device 0
    addr = 1d50:6108
    driver = lime
    label = LimeSDR-USB [USB 3.0] 90706024F3821
    media = USB 3.0
    module = FX3
    name = LimeSDR-USB
    serial = 00090706024F3821
\end{verbatim}

Further information about the LimeSDR and its channels was obtained using the following command:
\begin{verbatim}
    SoapySDRUtil --probe="driver=lime"
\end{verbatim}

\noindent The output of the above command can be viewed in the appendix \ref{lst: soapyProbe} and its information was used to configure the LimeSDR for sampling in the python script.

\noindent A python script was then created which utilised the SoapySDR API to sample and save data to a .bin file. The script is viewable in the Appendix \ref{app:limeSDRscript}, this was based on similar code sourced from DeepWave Digital for an Air-T SDR \cite{complexSamplingPython}. Noteably, as seen in the SoapySDR probe information \ref{lst:soapyProbe}, there was no automatic gain control for the LimeSDR RX1, therefore the low noise amplifier (LNA) gain was set to 30dB. The script was verified by saving a .bin file and then plotting the PSD of the sample, showing the DAB multiplex centered around 202.928 MHz, as seen below. 

% Image of the PSD of the LimeSDR
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.6\textwidth]{LimeSDRpsd.png}
    \caption{LimeSDR PSD Plot (DAB Multiplex 9A)}
    \label{fig:limeSDRpsd}
\end{figure}

Notably, given the LimeSDR has a 12 bit ADC, the output complex IQ data is 32 bits total, with a 16 bit real and 16 bit imaginary component (12 bits zero padded at LSB). The output settings of the LimeSDR are configured via the \textit{SOAPYSDRCS16} format. This resulted in the saved .bin file being 8.2MB for 1 second of data, again showing the high storage requirements for the testbed. On the RPi5, GQRX was also able to be utilised to view the waterfall plot of the LimeSDR, as seen in Figure \ref{fig:limeSDRwaterfall}, adding an additional layer of verification, other than the python script and source libraries. 

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.8\textwidth]{DVBtLime.png}
    \caption{LimeSDR Waterfall Plot (Channel 7 DVB-T Multiplex 177.5MHz)} 
    \label{fig:limeSDRwaterfall}
\end{figure}

In figure \ref{fig:limeSDRwaterfall}, the waterfall plot shows almost 10Mhz width of spectrum bandwidth, highlighting the capability of the LimeSDR to sample a wide bandwidth of spectrum. This is in contrast to the RTL-SDR which has a maximum sample rate of 3.2MS/s, and a bandwidth of 2.4MHz. Importantly, this bandwidth and sampling rate is also variable (via source scripting or API's), and multipel different sampling rates were experimented with during testing.

\subsection{RPi5 and NVME Testing \label{sec:sbcVerification}}
In order to compare and quantify the differences in the storage performance between the microSD card and the NVME SSD, a series of tests were conducted, utilising the following linux commands via the terminal of the RPi5.

\begin{verbatim}
    lsblk
    sudo hdparm -t --direct /dev/nvme0n1 
    sudo hdparm -t --direct /dev/mmcblk0
\end{verbatim}

\noindent Resulting in the following output seen below in Table \ref{tab:diskperf}.

\begin{table}[h!]
    \centering
    \caption{Disk Read Performance: NVMe vs MicroSD Card \label{tab:diskperf}}
    \begin{tabular}{|l|l|}
    \hline
    \textbf{Device} & \textbf{Read Performance} \\ \hline
    \texttt{NVMe SSD (\texttt{/dev/nvme0n1})} & \texttt{751.22 MB/sec} \\ \hline
    \texttt{MicroSD Card (\texttt{/dev/mmcblk0})} & \texttt{84.83 MB/sec} \\ \hline
    \end{tabular}
\end{table}

The results in Table \ref{tab:diskperf} clearly show the obtained significant performance increase when using the NVME SSD compared to the microSD card. Given the large amount of data that generated and processed during the SDR sampling. 

\subsection{Antenna Testing \label{sec:antennaVerification}}

Before calculations or detection was performed, the signal strength of the received signal was measured. This was done by first using the RTL-SDR and the monopole SMA antenna and compared to the Yagi-Uda antenna. The received signal strength, representing the illuminator DAB signal, was measured approximately 6km away from the transmitter tower. The results of the signal strength measurements are shown in Table \ref{tab:signalstrength}.

\begin{table}[h!]
    \centering
    \caption{Noise Floor and SNR Comparison with -14.2 dB Gain (RTL-SDR)}
    \label{tab:signalstrength}
    \begin{tabular}{|c|c|c|c|}
        \hline
        \textbf{Antenna Type} & \textbf{Noise Floor (dB)} & \textbf{Signal Strength (dB)} & \textbf{SNR (dB)} \\ \hline
        SMA Monopole & -60 & -40.9 & 19.1 \\ \hline
        Yagi-Uda     & -60 & -17   & 43   \\ \hline
    \end{tabular}
    \vspace{0.5cm}
\end{table}

The above table reflects the high gain of the Yagi-Uda antenna, which is a directional antenna, compared to the monopole SMA antenna. Overall, this testing was valuable to benchmark a noise floor and appreciate the neccessity for a high gain antenna, especially in the context of the low power target signal.

% GEOMETRY OF TESTING - image of geometry
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.9\textwidth]{testingGeometry.png}
    \caption{Antenna and Testbed Testing Geometry}
    \label{fig:antennaGeometry}
\end{figure}


\subsection{GPIO and Software Excecutable Testing \label{sec:gpioTesting}}

The GPIO buttons and LED's were tested using a simple python script, which was executed on the RPi5. The script was able to detect the button press and light the LED, as expected. This was a simple test, but was important to ensure the user interface was functioning correctly.   This was implemented via the gpiod library, which was installed on the RPi5. Specifically, the script utilised the gpiochip4 which is the GPIO chip on the RPi5. 

\par \vspace{0.5cm}
\noindent
Once basic arcade button functionality had been established, using the \textit{subprocess} library, the python script was tested executing the RTL-SDR sampling script as below:

\begin{verbatim}
    rtl_sdr_process = subprocess.Popen(['rtl_sdr', '-s', '2048000', '-f', 
    '202.928e6', '-n', '2048000', 'testData.bin'])
\end{verbatim}

\noindent This was tested with the lime SDR on the Debian baed Rpi5, and worked well. On both the Rpi5, the config/sampling and processing functionality was implemented through seperate Jupiter notebooks, for ease of use and debugging purposes along with timing and performance testing. These notebooks were migrated across to scripts for the final testbed implementation. The scripts were tested and integrated with the GPIO buttons and LED's, and the user interface was tested to ensure the user could start and stop the data collection and processing. In order to ensure execution at boot/run time on the Rpi5, the main testbed python script was configured via a \textbf{crontab} entry, which was tested and verified, and is viewable in the appendix. The efficacy of tis was tested via running the below command after boot:
% ADd code of crontab entry
\begin{verbatim}
    ps -ef | grep python
\end{verbatim}

The python script that is run by the crontab essentially polls the latch user buttons, and then sample and compute the data appropriately. The code for the python script and the crontab entry can be viewed in the appendix \todo{Add to appendix}.

\subsection{Detection Edge Processing Comparison} \label{sec:edgeProcessing}
Other than some configuration changes, the processing scripts for M1 Mac and the Rpi5 were essentially the same, revolving around range doppler processing windows of 500K samples. The figure below shows the processing time for the M1 Mac and the Rpi5, with the Rpi5 taking approximately 6 times longer to process the same amount of data.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.6\textwidth]{timeComparison.png}
    \caption{Processing Time Comparison}
    \label{fig:processingTime}
\end{figure}

The difference above is as expected, given the M1 Mac has a 8 core CPU and 16GB of RAM, compared to the Rpi5 which has a 4 core CPU and 8GB of RAM. The results highlight how networking the .bin files to a more powerful computer for processing could be a potential solution to the Rpi5's processing limitations.

\subsection{Enclosure Creation} \label{sec:enclosureResults}
Once the functionality of the testbed was verified, the enclosure was designed and 3D printed. The case design was modelled off source code from \cite{RPiCase}, however it was necessary to enhance the original design with cutouts for the user buttons and also stretch the top of the case to accomodate the SMA connectors and buttons. 

% Image of the enclosure design
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.8\textwidth]{RPiCase.png}
    \caption{Enclosure Design}
    \label{fig:enclosureDesign}
\end{figure}

Fusion 360 was used to design the case, and the STL files were then 3D printed. The design of the final case design can be seen in Figure \ref{fig:enclosureDesign}. The case was printed using a Bambu Lab P1S 3D printer, utilising the default PLA filament, which is not ideal given the potential heat generated by the RPi5 and the LimeSDR. The case was printed in two parts, the top and the bottom, and then assembled. However, given the active and passive cooling requirements of the RPi5 and the LimeSDR, it was deemed fit for purpose.


\section{RTL-SDR vs LimeSDR Detection Comparison \label{sec:SDRcomparison}}

\section{Overall Design Cost}

\section{Comparison to Existing Work}
% DISCUSS INTEGRATION INTO FLIGHT RADAR 24, etc
